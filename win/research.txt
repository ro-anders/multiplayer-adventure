In MFC (which is what Visual C++ uses) there are Dialog apps and SDI/MDI apps.  
Going with the Dialog.  It seems simpler and I have found example where you can directly draw into it
(http://stackoverflow.com/questions/2495188/how-to-add-canvas-in-mfc-dialog)

Basic idea is you have a CDC, the context in which you draw stuff, and GDIs, tools for drawing in that context.
Examples of GDIs are pens, brushes, and bitmaps.
Examples of CDCs are CWindowDC for drawing anywhere on the window (including menu bar), CClientDC and CPaintDC for 
  drawing in the app area of the window, and CMetaFileDC for creating a script.
HDC is a 32 bit handle to a Windows Device Context (don't know if it's just a pointer to a CDC or a pointer to the
  unerlying physical device that the CDC uses).
You can get a CClientDC from a window either on the stack "CClientDC cldc(pWindow);" or 
  on the heap "CDC* pDC = pWindow->GetDC();" but you must release the heap using "ReleaseDC(pDC);"
  ?? How do you know you get a CClientDC and not some other CDC subclass?



Hirschberg version had a main window with the following:
- title bar with text
    ? Do we need to worry about this, or did we do that with the project setup Wizard?
- reference to "the instance", hInstance
    ? Never appears to be used but it's global - is it used by MFC?
- reference to the main window component, gWnd
- drawing context to draw into that main window, gDC
    ? Is this what is used by PaintPixel to draw in the window?
- size and scale
- constructs for an off screen bitmap, bitsOffscreen(an array of ints) and bmpOffscreen(an HBITMAP)
- previous display mode (a DEVMODE) and previous window placement (a WINDOWPLACEMENT)
    ? for coming back from full screen

twinMain() seems to be the procedure that sets the window up
- Registers window with MFC (handles things like icons)
- creates main window hard coded to 712x484 at (400, 250)
- Initializes offscreen bitmap - see below
- Calls Adventure_Setup
- Displays window (windows calls ShowWindow() and UpdateWindow())
- sets up the timer task
- loops (this is the main gui thread) acting on GUI messages - until exit I think
- sets off some sort of kill
- destroys the bitmap

Initializing offscreen bitmap is done at creation and whenever size changes
- deletes the old bitmap
- sets the drawing context from the window
- configures the bitmap and creates a DIB? which allocates the int array

Timer Proc
- Creates drawing context from window 
- Sets up a NULL pen and the bitmap in the drawing context
- Runs the adventure code which calls PaintPixel 
  - just draws into the gDC drawing context
- Puts the old bitmap back in (implies PaintPixel doesn't change if paint to bitmap or directly to window)
- Releases and deletes drawing context (I guess because it's all in the bitmap)

WndProc - processes GUI messages like paint
- on resize, computes new size and reinitializes offscreen bitmap
- on paint calls 
                PAINTSTRUCT ps;
                HDC dc = BeginPaint(hWnd, &ps);
                EndPaint(hWnd, &ps);
  don't understand how that does anything, but that must paint the offscreen bitmap
- on erase background, wipes the whole screen black (do I have to do that?)
- handles other events like menu, destroy, ...


---------------------------------------------------------------

VStudio configuration I had to do:

1. Make a 32 bit application

  H2HAdventure->properties
  Configuration Manager
  Change Active Solution Platform = x86
  Change H2HAdventure Platform = Win32

2. Turn off PCH (Pre-compiled Headers)

  H2HAdventure->properties
  Configuration Properties->C/C++->Precompiled Headers
  Precompiled Header = Not using precompiled headers

3. Don't warn on sprintf classes

  H2HAdventure->properties
  Configuration Properties->C/C++->Preprocessor
  Preprocessor Definitions = _CRT_SECURE_NO_WARNINGS
                             <different options>


--------------------------------------------------------------------------------

Looking at an example of how to draw to the window first directly and then 
using a bitmap:

Drawing is done in OnDraw()
A pointer to a CDC is passed in and it draws a static square and an ellipse at a 
  dynamic point and size.
  - before it draws anythings it does
      CPoint point(0, 0);                  // logical (0, 0)
      pDC->LPtoDP(&point);                 // In device coordinates,
      pDC->SetBrushOrg(point);             //  align the brush with
    This handles mapping things (i think like if scrollbars are involved) 
    ???I don't really understand when I would want device coordinates and when I want logical coordinates???
    ???This handles when device and logical contexts have different origins, but they can also have different scales???
  - the square is drawn with a 
      pDC->Rectangle(CRect(100, -100, 200, -200))
  - the ellipse instead is drawn with a variable top-left CPoint and a constant CSize of (100, -100)
    ????Why -100???
  - when the mouse is dragged they take the mouse's position (a CPoint passed in to the mouseMove() callback), 
      pass it through DPtoLP(), and then set that to the top left variable
 
Whenever you drag the mouse it calls InvalidateRect (I guess to ask OnDraw to draw it again)

When migrated to using bitmap, all the OnDraw code remained the same, the mouse move 
  just changed the enigmatic second argument of IvalidateRect from TRUE to FALSE, and
  now has an OnPaint method (which seems to get called every time) that sets up a bitmap.

So what does it draw, invalidate, and bitblt?

Small drag started at [10,10,110,110] which was in the window [11,11,117,117] (Huh? Changed size?)
Invalidates [11,11,117,117]
 